class Observer {
    notify(from, data) {
    }
}

class Subject extends Observer {  // harmless inheritance, allows for Subject classes to be both
    subscribe(observer) {
        // this.observers.push(observer)

        /* 
        NOT AS EASY - OBSERVER PATTERN QUITE DIFFERENT TO EVENTING PATTERN

        Observer vs eventing architecture
        https://stackoverflow.com/questions/13441918/can-one-class-implement-both-subject-and-observer-sections-of-the-observer-desig

        Yet...
        There is nothing fundamental about the structure of the Observer pattern that would prevent this. 
        It's only a matter of making the Subject class implement the Observer interface (or equivalent), 
        and registering instances of that class.

        Also the "implicit invocation" pattern...
        https://en.wikipedia.org/wiki/Implicit_invocation
        The idea behind implicit invocation is that instead of invoking a procedure directly, 
        a component can announce (or broadcast) one or more events. 
        Other components in the system can register an interest in an event by associating a 
        procedure with the event. When the event is announced the system itself invokes 
        all of the procedures that have been registered for the event. 
        Thus an event announcement implicitly causes the invocation of procedures in other modules.

        Thus traditional observer pattern has an observer object watching a specific subject object
        whereas eventing systems are object agnostic, focussing on events invoking functions (no need for objects).
        Its the event name that is important, and the function to handle that broadcasted event that is important.
        So whilst the observer pattern's idea of not having objects abstractly wired to each other is great,
        its arguably beaten by the more flexible eventing model.

        */

        // document.addEventListener("modified todoitem", this.notify_func)
    }    
    notify_all(event_name, from, data) {
        console.log(`notify all of event '${event_name}' ${from != null ? 'from: ' + from.constructor.name : 'from unspecified'} ${data != null ? 'data: ' + data : ''}`)

        // rather than looping through the subject's 'this.observers' array, we broadcast more broadly
        document.dispatchEvent(new CustomEvent(event_name, { detail: { from: from, data: data } }))

        // debugging hook
        document.dispatchEvent(new CustomEvent("notify all called", { detail: { event_name: event_name, target: from, data: data } }))
    }
}

/**
 * Idiomatic Javascript eventing to implement Subject/Observer pattern
 *
 * Subjects call this function e.g. notify_all("hello")
 * Observers should be wired up with e.g. document.addEventListener("hello", (event) => { ... })
 * e.g.
 *    document.addEventListener("modified todoitem", (event) => { controller.notify(event) })
 * where in the sender's function
 *    notify_all(event_name, from, data)
 * the 'from' and 'data' end up in event.detail dict. Broadcasting 'from' and 'data' are optional.
 *
 *
 * The attribute event.detail can be interrogated by the receiving observer function for the 'from' and 'data' information
 * The attribute event.type is the event name e.g. "notify all called" or "modified todoitem"
 *
 * The custom event generated here is broadcast to the document element, an arbitrary decision
 *
 * To remove an event listener, use document.removeEventListener() and specify the function that
 * was originally registered. You cannot unhook anonymous functions, see https://www.w3schools.com/jsref/met_element_removeeventlistener.asp
 * You cannot remove functions that have been called using bind() cos this creates an anonymous function too.
 * But you can remember the func generated by using bind() in order to remove it.
 * See https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener for tips on removing
 * event listeners in special cases of custom events and function that are bound. Main thing is, the
 * event name (a string) and the function parameters to
 *    document.addEventListener(event_str, f)
 *    document.removeEventListener(event_str, f)
 * must match exactly - the f is tricky e.g. if an anonymous function is used then that can never
 * be matched again in the future. Also a known function that is 'tweaked' using .bind()
 * also creates an anonymous function too - but at least this can be remembered in order to be removed.
 *
 * @param {string} event_name name of the event
 * @param {object} from typically who is doing the notification, caller passes this in explicitly [optional]
 * @param {object or dictionary} data arbitrary info [optional]
 */
// function notify_all(event_name, from, data) {
//     console.log(`notify all of event '${event_name}' ${from != null ? 'from: ' + from.constructor.name : 'from unspecified'} ${data != null ? 'data: ' + data : ''}`)
//     document.dispatchEvent(new CustomEvent(event_name, { detail: {from: from, data: data } }))

//     // debugging hook
//     document.dispatchEvent(new CustomEvent("notify all called", { detail: {event_name: event_name, target: from, data: data } }))
//   }
